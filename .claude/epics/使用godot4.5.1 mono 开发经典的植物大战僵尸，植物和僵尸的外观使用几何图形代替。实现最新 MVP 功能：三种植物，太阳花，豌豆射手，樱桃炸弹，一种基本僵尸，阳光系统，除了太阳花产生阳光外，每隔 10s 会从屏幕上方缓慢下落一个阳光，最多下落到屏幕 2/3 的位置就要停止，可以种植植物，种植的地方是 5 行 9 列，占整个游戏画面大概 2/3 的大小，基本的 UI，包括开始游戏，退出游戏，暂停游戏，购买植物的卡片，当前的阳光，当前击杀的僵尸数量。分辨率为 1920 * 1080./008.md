---
name: 性能优化和测试
status: open
created: 2025-11-23T00:45:07Z
updated: 2025-11-23T00:45:07Z
github: [Will be updated when synced to GitHub]
depends_on: [007]
parallel: false
conflicts_with: []
---

# Task: 性能优化和测试

## Description
对完整的游戏进行性能优化、Bug修复和全面测试，确保游戏达到目标性能指标、质量标准和用户体验要求，为发布做好准备。

## Acceptance Criteria
- [ ] 游戏稳定运行在60 FPS，50+对象时不低于30 FPS
- [ ] 用户操作响应延迟低于100ms
- [ ] 游戏内存占用控制在512MB以内
- [ ] 游戏启动时间低于5秒
- [ ] 修复所有发现的严重Bug
- [ ] 通过完整的单元测试和集成测试
- [ ] 进行用户体验测试并获得积极反馈
- [ ] 代码符合C#编码规范和可维护性要求

## Technical Details

### 性能分析和优化
```csharp
public class PerformanceMonitor : Node
{
    [Export] public int TargetFPS { get; private set; } = 60;
    [Export] public int MinAcceptableFPS { get; private set; } = 30;

    private float fpsUpdateTime;
    private float currentFPS;
    private int objectCount;

    public override void _Ready()
    {
        Engine.MaxFps = TargetFPS;
    }

    public override void _Process(double delta)
    {
        UpdatePerformanceMetrics();
        CheckPerformanceThresholds();
    }

    private void UpdatePerformanceMetrics()
    {
        fpsUpdateTime += (float)delta;
        if (fpsUpdateTime >= 1.0f)
        {
            currentFPS = Engine.GetFramesPerSecond();
            objectCount = GetTree().GetNodeCount();
            fpsUpdateTime = 0f;

            LogPerformanceStats();
        }
    }

    private void CheckPerformanceThresholds()
    {
        if (currentFPS < MinAcceptableFPS)
        {
            GD.PrintErr($"性能警告: FPS {currentFPS:F1} 低于最小可接受值 {MinAcceptableFPS}");
            TriggerPerformanceOptimizations();
        }

        if (objectCount > 100)
        {
            GD.Print($"对象数量警告: 当前 {objectCount} 个对象");
        }
    }

    private void TriggerPerformanceOptimizations()
    {
        // 自动性能优化措施
        OptimizeCollisionDetection();
        OptimizeRenderCalls();
        OptimizeMemoryUsage();
    }

    private void OptimizeCollisionDetection()
    {
        // 优化碰撞检测频率
        var collisionAreas = GetTree().GetNodesInGroup("CollisionAreas");
        foreach (Area2D area in collisionAreas)
        {
            if (area.HasNode("OptimizedTimer"))
            {
                var timer = area.GetNode<Timer>("OptimizedTimer");
                if (!timer.IsStopped())
                {
                    area.SetProcess(false); // 临时禁用处理
                }
            }
        }
    }

    private void OptimizeRenderCalls()
    {
        // 合并相似的渲染调用
        var drawCalls = GetTree().GetNodesInGroup("DrawableObjects");
        // 实现批量渲染优化
    }

    private void OptimizeMemoryUsage()
    {
        // 清理未使用的对象
        GC.Collect();

        // 检查内存泄漏
        CheckMemoryLeaks();
    }

    private void CheckMemoryLeaks()
    {
        // 实现内存泄漏检测逻辑
        if (objectCount > 150) // 异常对象数量
        {
            GD.PrintErr("可能存在内存泄漏，请检查对象释放");
        }
    }

    private void LogPerformanceStats()
    {
        GD.Print($"性能统计 - FPS: {currentFPS:F1}, 对象数: {objectCount}, 内存: {GetMemoryUsage()}");
    }

    private string GetMemoryUsage()
    {
        // 获取内存使用情况的简化表示
        return "正常";
    }
}
```

### 对象池管理系统
```csharp
public class ObjectPoolManager : Node
{
    private Dictionary<string, Queue<Node>> pools;
    private Dictionary<string, PackedScene> prefabs;

    public override void _Ready()
    {
        pools = new Dictionary<string, Queue<Node>>();
        prefabs = new Dictionary<string, PackedScene>();
        InitializePools();
    }

    private void InitializePools()
    {
        // 初始化常用对象池
        CreatePool("Pea", "res://Scenes/Projectiles/Pea.tscn", 20);
        CreatePool("Sunlight", "res://Scenes/Sunlight.tscn", 10);
        CreatePool("BasicZombie", "res://Scenes/Zombies/BasicZombie.tscn", 15);
    }

    private void CreatePool(string poolName, string scenePath, int initialSize)
    {
        var scene = GD.Load<PackedScene>(scenePath);
        prefabs[poolName] = scene;
        pools[poolName] = new Queue<Node>();

        for (int i = 0; i < initialSize; i++)
        {
            var obj = scene.Instantiate();
            obj.Name = poolName;
            pools[poolName].Enqueue(obj);
        }
    }

    public Node GetPooledObject(string poolName)
    {
        if (!pools.ContainsKey(poolName))
        {
            GD.PrintErr($"对象池 '{poolName}' 不存在");
            return null;
        }

        Node obj;
        if (pools[poolName].Count > 0)
        {
            obj = pools[poolName].Dequeue();
        }
        else
        {
            obj = prefabs[poolName].Instantiate();
            GD.Print($"对象池 '{poolName}' 为空，创建新对象");
        }

        obj.Visible = true;
        return obj;
    }

    public void ReturnToPool(string poolName, Node obj)
    {
        if (!pools.ContainsKey(poolName))
            return;

        if (obj.GetParent() != null)
        {
            obj.GetParent().RemoveChild(obj);
        }

        obj.Visible = false;
        pools[poolName].Enqueue(obj);
    }
}
```

### 自动化测试系统
```csharp
public class GameTestRunner : Node
{
    [Export] public bool RunTestsOnStart { get; set; } = true;

    private List<TestCase> testCases;
    private TestResult currentResult;

    public override void _Ready()
    {
        if (RunTestsOnStart)
        {
            RunAllTests();
        }
    }

    public void RunAllTests()
    {
        testCases = new List<TestCase>();
        currentResult = new TestResult();

        CreateTestCases();
        ExecuteTestCases();
        GenerateTestReport();
    }

    private void CreateTestCases()
    {
        // 植物系统测试
        testCases.Add(new TestCase("TestSunflowerProduction", TestSunflowerProduction));
        testCases.Add(new TestCase("TestPeashooterShooting", TestPeashooterShooting));
        testCases.Add(new TestCase("TestCherryBombExplosion", TestCherryBombExplosion));

        // 僵尸系统测试
        testCases.Add(new TestCase("TestZombieMovement", TestZombieMovement));
        testCases.Add(new TestCase("TestZombieAttack", TestZombieAttack));

        // 经济系统测试
        testCases.Add(new TestCase("TestSunlightCollection", TestSunlightCollection));
        testCases.Add(new TestCase("TestPlantPurchase", TestPlantPurchase));

        // 战斗系统测试
        testCases.Add(new TestCase("TestProjectileCollision", TestProjectileCollision));
        testCases.Add(new TestCase("TestDamageCalculation", TestDamageCalculation));

        // 游戏流程测试
        testCases.Add(new TestCase("TestGameStateTransitions", TestGameStateTransitions));
        testCases.Add(new TestCase("TestVictoryConditions", TestVictoryConditions));
        testCases.Add(new TestCase("TestDefeatConditions", TestDefeatConditions));
    }

    private void ExecuteTestCases()
    {
        foreach (var testCase in testCases)
        {
            try
            {
                GD.Print($"运行测试: {testCase.Name}");
                testCase.TestMethod();
                currentResult.PassedTests.Add(testCase.Name);
                GD.Print($"✓ 测试通过: {testCase.Name}");
            }
            catch (Exception e)
            {
                currentResult.FailedTests.Add(testCase.Name, e.Message);
                GD.PrintErr($"✗ 测试失败: {testCase.Name} - {e.Message}");
            }
        }
    }

    private void TestSunflowerProduction()
    {
        // 测试太阳花阳光生产逻辑
        var sunflower = new Sunflower();
        sunflower._Ready();

        // 模拟5秒后应该产生阳光
        Assert.IsTrue(sunflower.CurrentSunlight >= 25, "太阳花应该在5秒后产生阳光");
    }

    private void TestPeashooterShooting()
    {
        // 测试豌豆射手射击逻辑
        var peashooter = new Peashooter();
        peashooter._Ready();

        // 模拟有僵尸在场的情况
        var result = peashooter.HasZombieInLane();
        Assert.IsTrue(result, "豌豆射手应该能检测到僵尸并射击");
    }

    private void TestZombieMovement()
    {
        // 测试僵尸移动逻辑
        var zombie = new BasicZombie();
        zombie._Ready();

        Vector2 initialPosition = zombie.Position;
        zombie._Process(1.0); // 模拟1秒
        Assert.IsTrue(zombie.Position.X < initialPosition.X, "僵尸应该向左移动");
    }

    private void TestSunlightCollection()
    {
        // 测试阳光收集逻辑
        var sunlightManager = new SunlightManager();
        sunlightManager._Ready();

        int initialSunlight = sunlightManager.CurrentSunlight;
        sunlightManager.AddSunlight(25);
        Assert.AreEqual(initialSunlight + 25, sunlightManager.CurrentSunlight, "阳光数量应该正确增加");
    }

    private void TestVictoryConditions()
    {
        // 测试胜利条件
        var gameFlowManager = new GameFlowManager();

        // 模拟击杀20个僵尸
        for (int i = 0; i < 20; i++)
        {
            GameManager.Instance.IncrementKillCount();
        }

        gameFlowManager.CheckVictoryConditions();
        Assert.IsTrue(GameManager.Instance.CurrentState == GameManager.GameState.Victory,
                     "击杀20个僵尸应该触发胜利");
    }

    private void Assert(bool condition, string message)
    {
        if (!condition)
        {
            throw new AssertionException(message);
        }
    }

    private void GenerateTestReport()
    {
        string reportPath = "user://test_report.txt";
        using (var file = FileAccess.Open(reportPath, FileAccess.ModeFlags.Write))
        {
            file.StoreLine("=== 游戏测试报告 ===");
            file.StoreLine($"测试时间: {DateTime.Now}");
            file.StoreLine($"通过测试: {currentResult.PassedTests.Count}");
            file.StoreLine($"失败测试: {currentResult.FailedTests.Count}");
            file.StoreLine($"测试覆盖率: {CalculateCoverage()}%");

            file.StoreLine("\n=== 通过的测试 ===");
            foreach (var test in currentResult.PassedTests)
            {
                file.StoreLine($"✓ {test}");
            }

            if (currentResult.FailedTests.Count > 0)
            {
                file.StoreLine("\n=== 失败的测试 ===");
                foreach (var kvp in currentResult.FailedTests)
                {
                    file.StoreLine($"✗ {kvp.Key}: {kvp.Value}");
                }
            }
        }
    }

    private float CalculateCoverage()
    {
        return (float)currentResult.PassedTests.Count / testCases.Count * 100f;
    }
}
```

### Bug修复和代码审查
```csharp
public class BugFixManager : Node
{
    private List<BugReport> bugReports;
    private Dictionary<string, bool> knownIssues;

    public override void _Ready()
    {
        InitializeKnownIssues();
        RunBugDetection();
    }

    private void InitializeKnownIssues()
    {
        knownIssues = new Dictionary<string, bool>
        {
            ["阳光点击失效"] = false,
            ["僵尸卡住"] = false,
            ["植物重叠"] = false,
            ["内存泄漏"] = false,
            ["性能下降"] = false
        };
    }

    private void RunBugDetection()
    {
        // 运行自动Bug检测
        CallDeferred(nameof(CheckForCommonBugs));
    }

    private void CheckForCommonBugs()
    {
        CheckSunlightClickBugs();
        CheckZombieStuckBugs();
        CheckPlantOverlapBugs();
        CheckMemoryLeakBugs();
        CheckPerformanceBugs();
    }

    private void CheckSunlightClickBugs()
    {
        var sunlights = GetTree().GetNodesInGroup("Sunlights");
        foreach (Sunlight sunlight in sunlights)
        {
            if (sunlight.GetCollider() == null)
            {
                ReportBug("阳光点击失效", "阳光对象缺少碰撞检测");
            }
        }
    }

    private void CheckZombieStuckBugs()
    {
        var zombies = GetTree().GetNodesInGroup("Zombies");
        foreach (Zombie zombie in zombies)
        {
            if (zombie.Position.X < 0 && zombie.IsAttacking)
            {
                ReportBug("僵尸卡住", "僵尸在边界外仍在攻击");
            }
        }
    }

    private void ReportBug(string bugType, string description)
    {
        if (!knownIssues[bugType])
        {
            GD.PrintErr($"Bug检测: {bugType} - {description}");
            knownIssues[bugType] = true;

            // 创建Bug报告
            var bugReport = new BugReport
            {
                Type = bugType,
                Description = description,
                Timestamp = DateTime.Now,
                Status = BugStatus.Open
            };
            bugReports.Add(bugReport);
        }
    }
}
```

### 用户体验测试
```csharp
public class UserExperienceTester : Node
{
    private List<UXTest> uxTests;

    public override void _Ready()
    {
        CreateUXTests();
        RunUXTests();
    }

    private void CreateUXTests()
    {
        uxTests = new List<UXTest>
        {
            new UXTest("界面响应性", TestUIResponsiveness),
            new UXTest("游戏平衡性", TestGameBalance),
            new UXTest("视觉清晰度", TestVisualClarity),
            new UXTest("操作直观性", TestIntuitiveControls)
        };
    }

    private void TestUIResponsiveness()
    {
        // 测试界面响应时间
        var stopwatch = new Stopwatch();

        stopwatch.Start();
        // 模拟用户操作
        stopwatch.Stop();

        if (stopwatch.ElapsedMilliseconds > 100)
        {
            GD.PrintWarn("UI响应时间超过100ms");
        }
    }

    private void TestGameBalance()
    {
        // 检查游戏平衡性
        var sunlightManager = GameManager.Instance.SunlightManager;
        var zombieManager = GameManager.Instance.ZombieManager;

        // 检查经济平衡
        if (sunlightManager.CurrentSunlight < 50 && zombieManager.CurrentWave > 3)
        {
            GD.PrintWarn("游戏平衡性: 阳光生产可能不足");
        }
    }
}
```

## Dependencies
- [ ] Task 007: 游戏流程完善完成 (完整游戏功能)

## Effort Estimate
- Size: L
- Hours: 32
- Parallel: false (最后阶段，需要完整功能)

## Definition of Done
- [ ] 所有性能指标达到目标要求
- [ ] 通过完整的单元测试和集成测试
- [ ] 修复所有严重Bug和已知问题
- [ ] 代码质量和可维护性达标
- [ ] 用户体验测试获得积极反馈
- [ ] 游戏稳定运行，可发布
- [ ] 生成完整的测试报告和性能分析