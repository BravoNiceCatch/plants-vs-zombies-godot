---
name: 阳光经济系统
status: open
created: 2025-11-23T00:45:07Z
updated: 2025-11-23T00:45:07Z
github: [Will be updated when synced to GitHub]
depends_on: [001, 002, 003]
parallel: true
conflicts_with: []
---

# Task: 阳光经济系统

## Description
实现完整的阳光经济系统，包括阳光的生成、收集、管理和植物购买机制，确保游戏经济平衡和玩家资源管理体验。

## Acceptance Criteria
- [ ] 实现阳光管理器，管理阳光数量、生成和收集逻辑
- [ ] 实现天降阳光系统，每10秒从顶部生成下落阳光
- [ ] 实现太阳花阳光生产，每5秒产生25单位阳光
- [ ] 创建阳光收集机制，支持点击收集和视觉反馈
- [ ] 实现植物购买系统，检查阳光充足性并扣除相应成本
- [ ] 阳光数量显示实时更新，支持最大999单位限制
- [ ] 阳光下落动画流畅，在屏幕2/3位置停止

## Technical Details

### 阳光管理器 (SunlightManager)
```csharp
public class SunlightManager : Node
{
    [Export] public int MaxSunlight { get; private set; } = 999;
    [Export] public int SunlightValue { get; private set; } = 25;
    [Export] public float SkyDropInterval { get; set; } = 10f;

    private int currentSunlight;
    private Timer skyDropTimer;
    private List<Sunlight> activeSunlights;

    public int CurrentSunlight
    {
        get => currentSunlight;
        private set
        {
            currentSunlight = Mathf.Clamp(value, 0, MaxSunlight);
            OnSunlightChanged?.Invoke(currentSunlight);
        }
    }

    public event Action<int> OnSunlightChanged;

    public override void _Ready()
    {
        activeSunlights = new List<Sunlight>();
        SetupSkyDropTimer();
    }

    public void AddSunlight(int amount)
    {
        CurrentSunlight += amount;
    }

    public bool CanAfford(int cost)
    {
        return CurrentSunlight >= cost;
    }

    public bool SpendSunlight(int cost)
    {
        if (CanAfford(cost))
        {
            CurrentSunlight -= cost;
            return true;
        }
        return false;
    }

    public void ProduceFromSunflower(Sunflower sunflower)
    {
        CreateSunlightAtPosition(sunflower.GlobalPosition, false);
    }

    private void SetupSkyDropTimer()
    {
        skyDropTimer = new Timer();
        skyDropTimer.WaitTime = SkyDropInterval;
        skyDropTimer.Timeout += OnGenerateSkySunlight;
        skyDropTimer.Autostart = true;
        AddChild(skyDropTimer);
    }

    private void OnGenerateSkySunlight()
    {
        Vector2 dropPosition = GetRandomSkyPosition();
        CreateSunlightAtPosition(dropPosition, true);
    }

    private Vector2 GetRandomSkyPosition()
    {
        float x = GD.RandRange(100f, 1820f); // 避免屏幕边缘
        float y = 50f; // 从顶部开始
        return new Vector2(x, y);
    }

    private void CreateSunlightAtPosition(Vector2 position, bool isSkyDrop)
    {
        var sunlight = new Sunlight(position, isSkyDrop);
        activeSunlights.Add(sunlight);
        sunlight.OnCollected += OnSunlightCollected;
        GetTree().Root.GetNode("GameScene").AddChild(sunlight);
    }

    private void OnSunlightCollected(Sunlight sunlight)
    {
        AddSunlight(SunlightValue);
        activeSunlights.Remove(sunlight);
        CreateCollectEffect(sunlight.GlobalPosition);
    }

    private void CreateCollectEffect(Vector2 position)
    {
        // 创建阳光收集的视觉效果
        var effectNode = new Node2D();
        effectNode.Position = position;

        var tween = CreateTween();
        tween.TweenProperty(effectNode, "scale", Vector2.One * 2f, 0.3f);
        tween.TweenProperty(effectNode, "modulate:a", 0f, 0.3f);
        tween.TweenCallback(Callable.From(() => effectNode.QueueFree()));

        GetTree().Root.AddChild(effectNode);
    }
}
```

### 阳光类 (Sunlight)
```csharp
public class Sunlight : Area2D
{
    [Export] public float FallSpeed { get; private set; } = 50f;
    [Export] public float MaxFallHeight { get; private set; } = 720f; // 屏幕2/3位置 (1080 * 2/3)

    public event Action<Sunlight> OnCollected;
    public bool IsSkyDrop { get; private set; }

    private bool isCollected;
    private bool hasStopped;

    public Sunlight(Vector2 position, bool isSkyDrop)
    {
        Position = position;
        IsSkyDrop = isSkyDrop;
        isCollected = false;
        hasStopped = false;
    }

    public override void _Ready()
    {
        SetupCollision();
        DrawSunlightShape();

        if (IsSkyDrop)
        {
            SetupFallAnimation();
        }
    }

    private void SetupCollision()
    {
        InputPickable = true; // 允许点击检测
        MouseEntered += OnMouseEntered;
        MouseExited += OnMouseExited;
        InputEvent += OnInputEvent;

        // 设置碰撞区域
        var collisionShape = new CollisionShape2D();
        var shape = new CircleShape2D();
        shape.Radius = 15f;
        collisionShape.Shape = shape;
        AddChild(collisionShape);
    }

    private void SetupFallAnimation()
    {
        var tween = CreateTween();
        Vector2 targetPosition = Position;
        targetPosition.Y = MaxFallHeight;

        tween.TweenProperty(this, "position", targetPosition,
            (targetPosition.Y - Position.Y) / FallSpeed);
        tween.TweenCallback(Callable.From(() => hasStopped = true));
    }

    private void OnInputEvent(Viewport viewport, InputEvent @event, int shapeIdx)
    {
        if (@event is InputEventMouseButton mouseEvent &&
            mouseEvent.Pressed &&
            mouseEvent.ButtonIndex == MouseButton.Left)
        {
            Collect();
        }
    }

    private void OnMouseEntered()
    {
        if (!isCollected)
        {
            // 鼠标悬停效果
            var tween = CreateTween();
            tween.TweenProperty(this, "scale", Vector2.One * 1.2f, 0.1f);
        }
    }

    private void OnMouseExited()
    {
        if (!isCollected)
        {
            var tween = CreateTween();
            tween.TweenProperty(this, "scale", Vector2.One, 0.1f);
        }
    }

    public void Collect()
    {
        if (isCollected) return;

        isCollected = true;
        OnCollected?.Invoke(this);

        PlayCollectAnimation();
    }

    private void PlayCollectAnimation()
    {
        var tween = CreateTween();
        tween.TweenProperty(this, "scale", Vector2.One * 0.5f, 0.2f);
        tween.TweenProperty(this, "modulate:a", 0f, 0.2f);
        tween.TweenCallback(Callable.From(() => QueueFree()));
    }

    private void DrawSunlightShape()
    {
        // 绘制阳光形状 (黄色星形或圆形)
    }

    // 添加生命周期管理，自动清理过期的天空阳光
    public override void _Process(double delta)
    {
        if (IsSkyDrop && !isCollected && hasStopped)
        {
            // 天降阳光在停止后10秒自动消失
            if (!HasNode("AutoDestroyTimer"))
            {
                var destroyTimer = new Timer();
                destroyTimer.WaitTime = 10f;
                destroyTimer.Timeout += () => QueueFree();
                destroyTimer.Name = "AutoDestroyTimer";
                AddChild(destroyTimer);
                destroyTimer.Start();
            }
        }
    }
}
```

### 植物购买系统 (PlantPurchaseSystem)
```csharp
public class PlantPurchaseSystem : Node
{
    private PlantFactory plantFactory;
    private SunlightManager sunlightManager;
    private GridSystem gridSystem;

    public PlantType SelectedPlant { get; private set; }
    public event Action<PlantType> OnPlantSelected;
    public event Action OnPlantPurchase;
    public event Action OnPurchaseFailed;

    public override void _Ready()
    {
        plantFactory = new PlantFactory();
        sunlightManager = GameManager.Instance.SunlightManager;
        gridSystem = GameManager.Instance.GridSystem;
    }

    public void SelectPlant(PlantType plantType)
    {
        SelectedPlant = plantType;
        OnPlantSelected?.Invoke(plantType);
    }

    public bool TryPurchasePlant(PlantType plantType, Vector2Int gridPosition)
    {
        if (!CanPurchasePlant(plantType, gridPosition))
        {
            OnPurchaseFailed?.Invoke();
            return false;
        }

        var plant = plantFactory.CreatePlant(plantType, gridPosition);
        if (plant == null)
        {
            OnPurchaseFailed?.Invoke();
            return false;
        }

        int cost = GetPlantCost(plantType);
        if (!sunlightManager.SpendSunlight(cost))
        {
            OnPurchaseFailed?.Invoke();
            plant.QueueFree();
            return false;
        }

        // 将植物添加到场景中
        PlacePlantInGrid(plant, gridPosition);

        OnPlantPurchase?.Invoke();
        return true;
    }

    private bool CanPurchasePlant(PlantType plantType, Vector2Int gridPosition)
    {
        // 检查阳光是否足够
        int cost = GetPlantCost(plantType);
        if (!sunlightManager.CanAfford(cost))
            return false;

        // 检查网格位置是否有效
        if (!gridSystem.IsValidGridPosition(gridPosition.Row, gridPosition.Col))
            return false;

        // 检查位置是否已被占用
        if (gridSystem.IsOccupied(gridPosition.Row, gridPosition.Col))
            return false;

        return true;
    }

    private int GetPlantCost(PlantType plantType)
    {
        return plantType switch
        {
            PlantType.Sunflower => 50,
            PlantType.Peashooter => 100,
            PlantType.CherryBomb => 150,
            _ => 0
        };
    }

    private void PlacePlantInGrid(Plant plant, Vector2Int gridPosition)
    {
        Vector2 worldPosition = gridSystem.GridToWorld(gridPosition.Row, gridPosition.Col);
        plant.Position = worldPosition;

        gridSystem.SetPlantAt(gridPosition.Row, gridPosition.Col, plant);
        GetTree().Root.GetNode("GameScene").AddChild(plant);

        plant.OnPlanted();
    }

    public void DeselectPlant()
    {
        SelectedPlant = PlantType.None;
    }
}
```

### 植物类型枚举
```csharp
public enum PlantType
{
    None,
    Sunflower,
    Peashooter,
    CherryBomb
}
```

### 网格位置结构
```csharp
public struct Vector2Int
{
    public int Row;
    public int Col;

    public Vector2Int(int row, int col)
    {
        Row = row;
        Col = col;
    }
}
```

## Dependencies
- [ ] Task 001: 项目基础搭建完成
- [ ] Task 002: 核心系统开发完成
- [ ] Task 003: UI界面开发完成 (用于显示阳光数量和植物卡片)

## Effort Estimate
- Size: M
- Hours: 20
- Parallel: true (可与游戏流程完善并行)

## Definition of Done
- [ ] 天降阳光每10秒正确生成并下落
- [ ] 太阳花每5秒产生阳光
- [ ] 阳光点击收集机制正常工作
- [ ] 植物购买系统正确检查阳光充足性
- [ ] 阳光数量实时显示和更新
- [ ] 阳光在屏幕2/3位置正确停止
- [ ] 经济系统与植物和UI系统正确集成
- [ ] 所有阳光功能通过单元测试和集成测试
- [ ] 阳光收集视觉效果流畅自然