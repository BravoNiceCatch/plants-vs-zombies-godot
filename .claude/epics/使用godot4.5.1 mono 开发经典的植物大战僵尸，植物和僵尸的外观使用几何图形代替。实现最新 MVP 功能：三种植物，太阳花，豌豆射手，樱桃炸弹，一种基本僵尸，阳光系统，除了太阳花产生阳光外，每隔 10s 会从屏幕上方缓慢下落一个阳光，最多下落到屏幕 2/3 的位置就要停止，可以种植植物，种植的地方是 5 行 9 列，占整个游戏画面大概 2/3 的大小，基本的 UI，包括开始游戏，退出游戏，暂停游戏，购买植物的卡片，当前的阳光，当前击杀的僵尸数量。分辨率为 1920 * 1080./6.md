---
name: 僵尸和战斗系统
status: open
created: 2025-11-23T00:45:07Z
updated: 2025-11-23T03:15:05Z
github: [Will be updated when synced to GitHub]
depends_on: [001, 002]
parallel: true
conflicts_with: [004]
---

# Task: 僵尸和战斗系统

## Description
实现基础僵尸AI系统、战斗机制和伤害计算，包括僵尸的移动、攻击、死亡逻辑，以及豌豆子弹的飞行和碰撞检测系统。

## Acceptance Criteria
- [ ] 实现基础僵尸类，包含移动、攻击、受伤和死亡行为
- [ ] 实现豌豆子弹系统，支持直线飞行和碰撞检测
- [ ] 实现战斗管理器，处理伤害计算和战斗状态
- [ ] 实现范围爆炸效果系统，支持樱桃炸弹的AOE伤害
- [ ] 创建僵尸管理器，控制僵尸的生成和行为
- [ ] 实现完整的战斗循环，包括攻击判定和死亡处理
- [ ] 使用几何图形表示僵尸和子弹外观

## Technical Details

### 僵尸基类 (Zombie)
```csharp
public abstract class Zombie : Node2D
{
    [Export] public float MoveSpeed { get; protected set; }
    [Export] public int MaxHealth { get; protected set; }
    [Export] public int Damage { get; protected set; }

    public int CurrentHealth { get; protected set; }
    public bool IsAttacking { get; protected set; }
    private Plant currentTarget;

    public override void _Ready()
    {
        CurrentHealth = MaxHealth;
        SetupMovement();
        DrawZombieShape();
    }

    public override void _Process(double delta)
    {
        if (!IsAttacking)
        {
            MoveForward((float)delta);
        }
        CheckForPlants();
    }

    protected virtual void MoveForward(float delta)
    {
        Position += new Vector2(-MoveSpeed * delta, 0);
    }

    private void CheckForPlants()
    {
        currentTarget = FindPlantInFront();
        if (currentTarget != null && !IsAttacking)
        {
            StartAttacking(currentTarget);
        }
        else if (currentTarget == null && IsAttacking)
        {
            StopAttacking();
        }
    }

    private void StartAttacking(Plant plant)
    {
        IsAttacking = true;
        currentTarget = plant;
        attackTimer.Start();
    }

    public virtual void TakeDamage(int damage)
    {
        CurrentHealth -= damage;
        PlayHitEffect();

        if (CurrentHealth <= 0)
        {
            Die();
        }
    }

    protected virtual void Die()
    {
        GameManager.Instance.IncrementKillCount();
        SpawnDeathEffect();
        QueueFree();
    }
}
```

### 基础僵尸 (BasicZombie)
```csharp
public class BasicZombie : Zombie
{
    public BasicZombie()
    {
        MoveSpeed = 26.67f; // 1格/3秒 (80像素/3秒)
        MaxHealth = 100;
        Damage = 10; // 每秒10点伤害
    }

    protected override void DrawZombieShape()
    {
        // 绘制简单的几何图形僵尸
        // 头部：灰色圆形
        // 身体：灰色矩形
        // 手臂：小矩形
    }
}
```

### 豌豆子弹 (Pea)
```csharp
public class Pea : Node2D
{
    [Export] public int Damage { get; private set; } = 20;
    [Export] public float Speed { get; private set; } = 400f; // 像素/秒

    private Area2D collisionArea;

    public override void _Ready()
    {
        SetupCollision();
        DrawPeaShape();
    }

    private void SetupCollision()
    {
        collisionArea = new Area2D();
        var collisionShape = new CollisionShape2D();
        var shape = new CircleShape2D();
        shape.Radius = 5f;
        collisionShape.Shape = shape;
        collisionArea.AddChild(collisionShape);
        AddChild(collisionArea);

        collisionArea.BodyEntered += OnBodyEntered;
    }

    public override void _Process(double delta)
    {
        Position += new Vector2(Speed * (float)delta, 0);
        RemoveIfOffscreen();
    }

    private void OnBodyEntered(Node body)
    {
        if (body is Zombie zombie)
        {
            zombie.TakeDamage(Damage);
            CreateHitEffect();
            QueueFree();
        }
    }

    private void DrawPeaShape()
    {
        // 绘制绿色圆形代表豌豆
    }
}
```

### 战斗管理器 (CombatManager)
```csharp
public class CombatManager : Node
{
    private List<Projectile> activeProjectiles;
    private List<Explosion> activeExplosions;

    public override void _Ready()
    {
        activeProjectiles = new List<Projectile>();
        activeExplosions = new List<Explosion>();
    }

    public void RegisterProjectile(Projectile projectile)
    {
        activeProjectiles.Add(projectile);
    }

    public void UnregisterProjectile(Projectile projectile)
    {
        activeProjectiles.Remove(projectile);
    }

    public void TriggerExplosion(Vector2 position, float radius, int damage)
    {
        var explosion = new Explosion(position, radius, damage);
        activeExplosions.Add(explosion);

        // 处理范围内的僵尸
        var zombies = GetTree().GetNodesInGroup("Zombies");
        foreach (Zombie zombie in zombies)
        {
            float distance = zombie.GlobalPosition.DistanceTo(position);
            if (distance <= radius)
            {
                zombie.TakeDamage(damage);
            }
        }

        CreateExplosionEffect(position, radius);
    }

    private void CreateExplosionEffect(Vector2 position, float radius)
    {
        // 创建爆炸视觉效果
        var explosionNode = new Node2D();
        explosionNode.Position = position;

        // 使用粒子系统或简单动画
        var animationTween = CreateTween();
        animationTween.TweenProperty(explosionNode, "scale", Vector2.One * (radius / 50f), 0.2f);
        animationTween.TweenCallback(Callable.From(() => explosionNode.QueueFree()));

        GetTree().Root.AddChild(explosionNode);
    }
}
```

### 僵尸管理器 (ZombieManager)
```csharp
public class ZombieManager : Node
{
    [Export] public float FirstWaveDelay { get; set; } = 30f;
    [Export] public float WaveInterval { get; set; } = 20f;
    [Export] public PackedScene BasicZombieScene { get; set; }

    private Timer waveTimer;
    private int currentWave = 0;

    public override void _Ready()
    {
        SetupWaveTimer();
        BasicZombieScene = GD.Load<PackedScene>("res://Scenes/Zombies/BasicZombie.tscn");
    }

    private void SetupWaveTimer()
    {
        waveTimer = new Timer();
        waveTimer.WaitTime = FirstWaveDelay;
        waveTimer.Timeout += OnFirstWave;
        waveTimer.OneShot = true;
        AddChild(waveTimer);
        waveTimer.Start();
    }

    private void OnFirstWave()
    {
        SpawnWave();

        waveTimer.WaitTime = WaveInterval;
        waveTimer.Timeout += OnSubsequentWave;
        waveTimer.OneShot = false;
        waveTimer.Start();
    }

    private void OnSubsequentWave()
    {
        currentWave++;
        SpawnWave();
    }

    private void SpawnWave()
    {
        int zombieCount = CalculateZombieCount(currentWave);
        SpawnZombies(zombieCount);
    }

    private int CalculateZombieCount(int wave)
    {
        return 1 + wave; // 简单的难度递增
    }

    private void SpawnZombies(int count)
    {
        for (int i = 0; i < count; i++)
        {
            CallDeferred(nameof(SpawnSingleZombie));
        }
    }

    private void SpawnSingleZombie()
    {
        int row = GD.RandRange(0, GridSystem.ROWS - 1);
        Vector2 spawnPosition = GetSpawnPosition(row);

        var zombie = BasicZombieScene.Instantiate<BasicZombie>();
        zombie.Position = spawnPosition;
        zombie.AddToGroup("Zombies");
        GetTree().Root.GetNode("GameScene").AddChild(zombie);
    }

    private Vector2 GetSpawnPosition(int row)
    {
        float y = GridSystem.GRID_START_Y + row * GridSystem.CELL_SIZE;
        return new Vector2(1920, y); // 从屏幕右侧出现
    }

    public bool HasZombieInRow(int row)
    {
        var zombies = GetTree().GetNodesInGroup("Zombies");
        foreach (Zombie zombie in zombies)
        {
            if (zombie.Position.Y >= row * GridSystem.CELL_SIZE &&
                zombie.Position.Y < (row + 1) * GridSystem.CELL_SIZE)
            {
                return true;
            }
        }
        return false;
    }
}
```

### 爆炸类 (Explosion)
```csharp
public class Explosion
{
    public Vector2 Position { get; }
    public float Radius { get; }
    public int Damage { get; }
    public bool IsActive { get; private set; }

    public Explosion(Vector2 position, float radius, int damage)
    {
        Position = position;
        Radius = radius;
        Damage = damage;
        IsActive = true;
    }

    public void Deactivate()
    {
        IsActive = false;
    }
}
```

## Dependencies
- [ ] Task 001: 项目基础搭建完成
- [ ] Task 002: 核心系统开发完成 (GameManager, GridSystem)

## Effort Estimate
- Size: L
- Hours: 28
- Parallel: true (可与植物系统并行)

## Definition of Done
- [ ] 僵尸能够正确生成、移动和攻击
- [ ] 豌豆子弹飞行和碰撞检测正常工作
- [ ] 战斗系统正确计算和处理伤害
- [ ] 爆炸效果和AOE伤害机制正常
- [ ] 僵尸管理器按正确的时间和数量生成僵尸
- [ ] 战斗系统与植物系统正确集成
- [ ] 所有战斗功能通过单元测试和集成测试
- [ ] 性能满足要求 (50+战斗对象同时运行)